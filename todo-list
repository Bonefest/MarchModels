1. CVar system
2. Global configurations system
3. Dynamic resolution for image integrator
4. Label at the bottom "FPS, frame took x ms"
5. Output compile log into a dedicated window
6. Add list of built-in arguments in script function settings window
7. Fix forking problem
8. Recalculate geometry when its relative position in parent's branch has changed (aabb should not be recalculated)
9. Add turn on/turn off button, probably only for 2+ geometries in the branch or union-only
10. We should not be able to change script function type if it's used by some geometry or geometry should additionally recheck and update its scripts (e.g move sdf to odfs list or vice versa)
11. add time to logger's messages
12. instance and prototype should be two different windows
13. sync function for script function settings
14. two camera control modes: FPS-like, righ-click-like; ability to rotate selected geometry with right-click-like mode and move with pressed left button
15. clear log history button
16. ability to change center of mass
17. text input for time
18. visualize three types of AABBs (native, dynamic, final)
19. manual AABB setup
20. check native aabb size, decide whether it's bounded
21. config settings manager (window with cvars)
22. check in rasterization pass if intersection was found on the previous iteration and skip in positive case
23. ODFs of the leaf additionally may get access to the float3 point value.
24. ability to swtich to "smooth" combination functions
25. ability to incorporate custom combination function (final AABB calculation should be adapted in this case, since we have a risk of losing conservativeness of the AABB)
26. We incorrectly calculate values in z buffer, what we should really store is z value, not distance (hence, we should find a point in world space, project it in the NDC and store that value instead)
27. add rendererGetPass(name) function - bools like "enable normals" may be obsolete, because we can control the passes directly. Gives us more flexibilty: allows to add parameters to the passes and control them from the editor.
28. add renderPassDrawInputView() - allows to incapsulate input view
29. double click on a geometry, will change camera's position to center view on the geometry
30. wind function / parameter
31. add additional check if traversed distance > some threshold (and e.g modify stencil mask)
32. instead of discarding rays that haven't intersected a surface, consider them as intersected, in case if minimal distance to the surface was smaller than some threshold2
33. chance to fix camera's frustum (disable recalculations)
34. visualization of a frustum
35. statistics of culled objects
36. We can easily render plane as two triangles (in case if we don't need ray marching features and simply need render sort of a ground)
37. before rasterizing a leaf, project its AABB on the screen (in case it's bounded or based on some heuristic, e.g volume size < some value)
38. split rasterization pass up: rasterization preparation and extraction steps are decorators. Rasterization pass can also be applied to the shadowing pass (shadowing pass only prepares rays and extracts results in some other way and provides some other point of view)
39. store all geotransforms in a single UBO
40. set blending settings only at the beginning of the rasterization, set framebuffer only at the beginning of the rasterization
41. add some clue to the view, to understand what's camera orientation